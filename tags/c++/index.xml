<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on 6cdh's Blog</title><link>https://6cdh.github.io/tags/c++/</link><description>Recent content in C++ on 6cdh's Blog</description><generator>Hugo</generator><language>en</language><lastBuildDate>Wed, 21 Apr 2021 23:41:50 +0800</lastBuildDate><atom:link href="https://6cdh.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>How new is implemented</title><link>https://6cdh.github.io/posts/newdelete/</link><pubDate>Wed, 21 Apr 2021 23:41:50 +0800</pubDate><guid>https://6cdh.github.io/posts/newdelete/</guid><description>&lt;p>You may be asked what&amp;rsquo;s the difference between &lt;code>new&lt;/code> and &lt;code>malloc&lt;/code>. In fact, they are completely different. However, in a sense, they are almost no difference.&lt;/p></description></item><item><title>How Compilers Initialize C style array</title><link>https://6cdh.github.io/posts/initializer/</link><pubDate>Tue, 13 Apr 2021 16:39:06 +0800</pubDate><guid>https://6cdh.github.io/posts/initializer/</guid><description>&lt;p>In C++11, you can initialize all members of a C-style array to zero.&lt;/p></description></item><item><title>模板特化与实例化</title><link>https://6cdh.github.io/posts/specialization-instantiation/</link><pubDate>Sat, 16 Jan 2021 10:42:26 +0000</pubDate><guid>https://6cdh.github.io/posts/specialization-instantiation/</guid><description>&lt;p>模板特化和实例化有时挺让人迷惑.&lt;/p></description></item><item><title>标准库中的字符串搜索</title><link>https://6cdh.github.io/posts/string-match/</link><pubDate>Sat, 21 Nov 2020 00:00:00 +0000</pubDate><guid>https://6cdh.github.io/posts/string-match/</guid><description>&lt;p>给定文本 T(ext) 和模式 P(attern), 字符串搜索问题在 T 中寻找 P 出现的位置.&lt;/p></description></item><item><title>C++ 模板参数推导</title><link>https://6cdh.github.io/posts/template-argument-deduction/</link><pubDate>Mon, 19 Oct 2020 22:14:18 +0000</pubDate><guid>https://6cdh.github.io/posts/template-argument-deduction/</guid><description>&lt;p>实例化函数模板时, 模板实参必须是已知的, 但不必显式指定. 编译器会从函数模板的实参中推导缺失的模板实参. 另外模板参数推导也可以在 auto 说明符的上下文中从初始化器推导变量的类型.&lt;/p></description></item><item><title>C++ 中的 virtual 函数和 RTTI</title><link>https://6cdh.github.io/posts/cpp_virtual_rtti/</link><pubDate>Wed, 23 Sep 2020 02:52:13 +0000</pubDate><guid>https://6cdh.github.io/posts/cpp_virtual_rtti/</guid><description>&lt;p>C++ 中的 virtual 说明符指定非静态成员函数为虚函数, 并支持基类和派生类的运行时调用. 只要在基类和派生类中重载虚函数, 当使用基类的引用或指针指向派生类的对象时, 对该指针或引用调用虚函数依然可以调用派生类的虚函数, 判断要调用哪个虚函数是在运行时实现的. RTTI (Run-Time Type Information) 是一种机制, 允许在运行时判断对象的类型信息. 同样是运行时, 两者的实现实际上是相似的. 这很有趣, 本文会深入一下它们的原理.&lt;/p></description></item><item><title>二分搜索及其变种</title><link>https://6cdh.github.io/posts/binary_search/</link><pubDate>Wed, 23 Sep 2020 02:52:13 +0000</pubDate><guid>https://6cdh.github.io/posts/binary_search/</guid><description>&lt;p>二分搜索 &lt;em>(binary search)&lt;/em> 也称折半搜索 &lt;em>(half-interval search)&lt;/em>, 用于在有序数组上搜索给定值的位置. 这是一个常见的搜索算法, 似乎没什么难度. 然而, 在解决 &lt;a href="https://leetcode.com/problems/search-insert-position/">Leetcode 35 (Search Insert Position)&lt;/a> 时, 我意识到对二分搜索及其变种的理解还不够, 因此记录一下.&lt;/p></description></item></channel></rss>