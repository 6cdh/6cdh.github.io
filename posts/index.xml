<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 6cdh's Blog</title><link>https://6cdh.github.io/posts/</link><description>Recent content in Posts on 6cdh's Blog</description><generator>Hugo</generator><language>en</language><lastBuildDate>Thu, 27 Jun 2024 15:19:28 +0800</lastBuildDate><atom:link href="https://6cdh.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>On Read/Write Code</title><link>https://6cdh.github.io/posts/on-read-write-code/</link><pubDate>Thu, 27 Jun 2024 15:19:28 +0800</pubDate><guid>https://6cdh.github.io/posts/on-read-write-code/</guid><description>&lt;p>Recently I&amp;rsquo;ve been thinking about how to improve reading and writing code. Here are some ideas for discussion.&lt;/p></description></item><item><title>Keep Healthy</title><link>https://6cdh.github.io/posts/keep-healthy/</link><pubDate>Wed, 23 Aug 2023 10:13:18 +0800</pubDate><guid>https://6cdh.github.io/posts/keep-healthy/</guid><description>&lt;p>Many young people have unhealthy routines and habits. This post will introduce a reason why we should have healthy routines and habits.&lt;/p></description></item><item><title>How to programming fast</title><link>https://6cdh.github.io/posts/how-to-be-fast/</link><pubDate>Tue, 08 Aug 2023 21:17:05 +0800</pubDate><guid>https://6cdh.github.io/posts/how-to-be-fast/</guid><description>&lt;p>I have a good understanding of algorithms, data structures, logic, program verification, and Vim keybindings. Why am I not fast as I thought?&lt;/p></description></item><item><title>Reopen my blog</title><link>https://6cdh.github.io/posts/reopen/</link><pubDate>Tue, 08 Aug 2023 11:13:01 +0800</pubDate><guid>https://6cdh.github.io/posts/reopen/</guid><description>&lt;p>I want to reopen my blog suddenly.&lt;/p></description></item><item><title>How new is implemented</title><link>https://6cdh.github.io/posts/newdelete/</link><pubDate>Wed, 21 Apr 2021 23:41:50 +0800</pubDate><guid>https://6cdh.github.io/posts/newdelete/</guid><description>&lt;p>You may be asked what&amp;rsquo;s the difference between &lt;code>new&lt;/code> and &lt;code>malloc&lt;/code>. In fact, they are completely different. However, in a sense, they are almost no difference.&lt;/p></description></item><item><title>How Compilers Initialize C style array</title><link>https://6cdh.github.io/posts/initializer/</link><pubDate>Tue, 13 Apr 2021 16:39:06 +0800</pubDate><guid>https://6cdh.github.io/posts/initializer/</guid><description>&lt;p>In C++11, you can initialize all members of a C-style array to zero.&lt;/p></description></item><item><title>The Behavior of Modulo operation</title><link>https://6cdh.github.io/posts/modulo_operation/</link><pubDate>Tue, 16 Mar 2021 23:02:50 +0800</pubDate><guid>https://6cdh.github.io/posts/modulo_operation/</guid><description>&lt;p>The modulo operator can be found in almost every programming language. However, the
behavior of how they are defined depends on the language.&lt;/p></description></item><item><title>The Stack Sorting</title><link>https://6cdh.github.io/posts/stack/</link><pubDate>Wed, 10 Mar 2021 12:32:42 +0800</pubDate><guid>https://6cdh.github.io/posts/stack/</guid><description>&lt;p>Recently, I got stuck in the stack data structure. Everyone knows that the stack is a LIFO &lt;em>(Last In First Out)&lt;/em> data structure. This is easy to understand, but not easy to use sometimes.&lt;/p></description></item><item><title>The Welfare Crook</title><link>https://6cdh.github.io/posts/the-welfare-crook/</link><pubDate>Thu, 21 Jan 2021 20:52:12 +0000</pubDate><guid>https://6cdh.github.io/posts/the-welfare-crook/</guid><description>&lt;p>题目 The Welfare Crook, 出自 &amp;ldquo;Science of Programming&amp;rdquo;:&lt;/p>
&lt;blockquote>
&lt;p>Suppose we have three long magnetic tapes, each containing a list of names in alphabetical order. The first list contains the names of people woring at IBM Yorktown, the second the names of students at Columbia University and the third the names of people on welfare in New York City. Practically speaking, all three lists are endless, so no upper bounds are given. It is known that at least one person is on all three lists. Write a program to locate the first such person (the one with the alphabetically smallest person).&lt;/p></description></item><item><title>模板特化与实例化</title><link>https://6cdh.github.io/posts/specialization-instantiation/</link><pubDate>Sat, 16 Jan 2021 10:42:26 +0000</pubDate><guid>https://6cdh.github.io/posts/specialization-instantiation/</guid><description>&lt;p>模板特化和实例化有时挺让人迷惑.&lt;/p></description></item><item><title>使用元素间索引</title><link>https://6cdh.github.io/posts/index_between_elements/</link><pubDate>Mon, 23 Nov 2020 22:30:00 +0000</pubDate><guid>https://6cdh.github.io/posts/index_between_elements/</guid><description>&lt;p>使用索引还是迭代器? 从 0 开始还是从 1 开始? 左闭右开还是左开右闭? 亦或是全闭/全开区间? 索引产生的微小错误让人混乱? (这也叫差一错误 &lt;em>(off-by-one error)&lt;/em>). 如果你曾为这些问题困扰, 那么元素间索引的思想或许可以帮助你.&lt;/p></description></item><item><title>标准库中的字符串搜索</title><link>https://6cdh.github.io/posts/string-match/</link><pubDate>Sat, 21 Nov 2020 00:00:00 +0000</pubDate><guid>https://6cdh.github.io/posts/string-match/</guid><description>&lt;p>给定文本 T(ext) 和模式 P(attern), 字符串搜索问题在 T 中寻找 P 出现的位置.&lt;/p></description></item><item><title>C++ 模板参数推导</title><link>https://6cdh.github.io/posts/template-argument-deduction/</link><pubDate>Mon, 19 Oct 2020 22:14:18 +0000</pubDate><guid>https://6cdh.github.io/posts/template-argument-deduction/</guid><description>&lt;p>实例化函数模板时, 模板实参必须是已知的, 但不必显式指定. 编译器会从函数模板的实参中推导缺失的模板实参. 另外模板参数推导也可以在 auto 说明符的上下文中从初始化器推导变量的类型.&lt;/p></description></item><item><title>C++ 中的 virtual 函数和 RTTI</title><link>https://6cdh.github.io/posts/cpp_virtual_rtti/</link><pubDate>Wed, 23 Sep 2020 02:52:13 +0000</pubDate><guid>https://6cdh.github.io/posts/cpp_virtual_rtti/</guid><description>&lt;p>C++ 中的 virtual 说明符指定非静态成员函数为虚函数, 并支持基类和派生类的运行时调用. 只要在基类和派生类中重载虚函数, 当使用基类的引用或指针指向派生类的对象时, 对该指针或引用调用虚函数依然可以调用派生类的虚函数, 判断要调用哪个虚函数是在运行时实现的. RTTI (Run-Time Type Information) 是一种机制, 允许在运行时判断对象的类型信息. 同样是运行时, 两者的实现实际上是相似的. 这很有趣, 本文会深入一下它们的原理.&lt;/p></description></item><item><title>二分搜索及其变种</title><link>https://6cdh.github.io/posts/binary_search/</link><pubDate>Wed, 23 Sep 2020 02:52:13 +0000</pubDate><guid>https://6cdh.github.io/posts/binary_search/</guid><description>&lt;p>二分搜索 &lt;em>(binary search)&lt;/em> 也称折半搜索 &lt;em>(half-interval search)&lt;/em>, 用于在有序数组上搜索给定值的位置. 这是一个常见的搜索算法, 似乎没什么难度. 然而, 在解决 &lt;a href="https://leetcode.com/problems/search-insert-position/">Leetcode 35 (Search Insert Position)&lt;/a> 时, 我意识到对二分搜索及其变种的理解还不够, 因此记录一下.&lt;/p></description></item></channel></rss>