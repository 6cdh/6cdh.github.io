<!doctype html><html xmlns=http://www.w3.org/1999/xhtml lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>使用元素间索引 | 6cdh's Blog</title><meta property='og:title' content="使用元素间索引 - 6cdh's Blog"><meta property='og:description' content='使用索引还是迭代器? 从 0 开始还是从 1 开始? 左闭右开还是左开右闭? 亦或是全闭/全开区间? 索引产生的微小错误让人混乱? (这也叫差一错误 (off-by-one error)). 如果你曾为这些问题困扰, 那么元素间索引的思想或许可以帮助你.'><meta property='og:url' content='https://6cdh.github.io/posts/index_between_elements/'><meta property='og:site_name' content="6cdh's Blog"><meta property='og:type' content='article'><meta property='og:image' content='https://www.gravatar.com/avatar/b8cddc4add92aa9aa4ad41498604c028?s=256'><meta property='article:section' content='Posts'><meta property='article:tag' content='programming'><meta property='article:published_time' content='2020-11-23T22:30:00Z'><meta property='article:modified_time' content='2020-11-23T22:30:00Z'><meta name=twitter:card content='summary'><meta name=twitter:site content='@'><meta name=twitter:creator content='@'><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://6cdh.github.io/custom.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://6cdh.github.io/posts/index_between_elements/><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"></head><body><section class=section><div class=container><nav id=nav-main class=nav><div id=nav-name class=nav-left><a id=nav-anchor class=nav-item href=https://6cdh.github.io/><h1 id=nav-heading class="title is-4">6cdh's Blog</h1></a></div><div class=nav-right><nav id=nav-items class="nav-item level is-mobile"><a class=level-item aria-label=github href=https://github.com/6cdh target=_blank rel='me noopener'><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</i></span></a><a class=level-item aria-label=email href=mailto:cd6cdh@gmail.com target=_blank rel='me noopener'><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
</i></span></a><a class=level-item aria-label=rss href=/index.xml target=_blank rel='me noopener'><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></i></span></a></nav></div></nav><nav class=nav></nav></div><script src=/js/navicon-shift.js></script></section><section class=section><div class=container><div class="subtitle tags is-6 is-pulled-right"><a class="subtitle is-6" href=/tags/programming/>#programming</a></div><h2 class="subtitle is-6">November 23, 2020</h2><h1 class=title>使用元素间索引</h1><div class=content><p>使用索引还是迭代器? 从 0 开始还是从 1 开始? 左闭右开还是左开右闭? 亦或是全闭/全开区间? 索引产生的微小错误让人混乱? (这也叫差一错误 <em>(off-by-one error)</em>). 如果你曾为这些问题困扰, 那么元素间索引的思想或许可以帮助你.</p><p>本文的灵感来自于 <a href=https://blog.nelhage.com/2015/08/indices-point-between-elements/>Nelson Elhage 的博客</a>.</p><p>数组是什么? 如果你熟悉主流编程语言, 你可能给出如下答案:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>+---+---+---+---+---+---+
</span></span><span style=display:flex><span>| 0 | 1 | 2 | 3 | 4 | 5 |
</span></span><span style=display:flex><span>+---+---+---+---+---+---+
</span></span></code></pre></div><p>方框内的是索引, 从 0 开始. 也有从 1 开始的索引方式, 这里为了方便, 用最常见的 0 开始. 以下称这种方法为普通索引方法.</p><p>元素间索引使用如下的方式索引</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>+---+---+---+---+---+---+
</span></span><span style=display:flex><span>|   |   |   |   |   |   |
</span></span><span style=display:flex><span>+---+---+---+---+---+---+
</span></span><span style=display:flex><span>0   1   2   3   4   5   6
</span></span></code></pre></div><p>每个索引指向元素之间的空隙. 这样, 原来用单个索引表示的元素现在用一个二元组表示. 例如, 原来的 <code>A[0]</code> 现在变成了二元组 <code>(0, 1)</code>.</p><p>这样有什么好处呢? 显而易见的一个好处是易于表示范围.</p><h2 id=范围的表示>范围的表示</h2><p>假设我们用 X 表示范围:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>  0   1   2   3   4   5
</span></span><span style=display:flex><span>+---+---+---+---+---+---+
</span></span><span style=display:flex><span>|   | X | X | X |   |   |
</span></span><span style=display:flex><span>+---+---+---+---+---+---+
</span></span><span style=display:flex><span>0   1   2   3   4   5   6
</span></span></code></pre></div><p>用普通索引方式会产生多种表示:</p><ol><li>左闭右开区间 <code>[1, 4)</code>.</li><li>全闭区间 <code>[1, 3]</code>.</li><li>左开右闭区间 <code>(0, 3]</code>.</li><li>全开区间 <code>(0, 4)</code>.</li><li>索引加长度有序对 <code>(1, 3)</code>.</li><li>反向索引. 数组最后一个元素的索引是 -1, 然后向前递减, 继而再次引申出使用负数的前面几种表示.</li><li>&mldr;</li></ol><p>这么多的选择, 如果不始终坚持一种写法, 很容易引发错误. 即使始终坚持一种写法, 也可能由于不符合直觉引发错误. 一般, 我们选择左闭右开的写法, 后面会对这一选择的原因进行讨论.</p><p>对于元素间索引, 如果要表示范围, 答案是唯一的: <code>(1, 4)</code>. 而且, 它是相当符合直觉的. 不会在写大量操作索引的代码的时候突然懵了: 最左边的元素被包含吗? 最右边的元素被包含吗?</p><p>这种方式表示范围还有一个好处是易于表示区间之间的关系. 例如, 对于用元素间索引表示的两个区间 A: <code>(a, b)</code>, B: <code>(c, d)</code>, 有六种关系:</p><ol><li>B 在 A 的右边且和 A 不重叠. 即满足 <code>b &lt;= c</code>.</li><li>B 在 A 的左边且和 A 不重叠. 即满足 <code>d &lt;= a</code>.</li><li>B 在 A 的左边且和 A 重叠. <code>a &lt; c &lt; b &lt; d</code>.</li><li>B 在 A 的右边且和 A 重叠. <code>c &lt; a &lt; d &lt; b</code>.</li><li>B 包含 A. <code>c &lt;= a &lt; b &lt;= d</code>.</li><li>A 包含 B. <code>a &lt;= c &lt; d &lt;= b</code>.</li></ol><p>只要画一下图, 上述结果很容易导出, 而且导出的结果也很直观, 具有对称性.</p><p>快速回答一下: 元素间索引表示的区间 <code>(1, 4)</code> 和 <code>(2, 5)</code> 是什么关系? 无需看上面的六种关系, 你可以直接得出结论: <code>(1, 4)</code> 在 <code>(2, 5)</code> 左边且和 <code>(2, 5)</code> 部分重叠.</p><p>再次快速回答一下: 对于左闭右开表示法, <code>[1, 4)</code> 和 <code>[2, 5)</code> 是什么关系? 可能在经过数秒的思考后, 你才能得出结论.</p><p>元素间索引表示的范围可以轻松计算元素数量: 对于 <code>(2, 5)</code>, 元素数量为 5 - 2 = 3. 无需进行加/减 1.
更无需判断是哪种表示法, 然后再判断加 1 还是减 1, 因为元素间索引只有一种表示.</p><p>完美! 但是, 怎么在实践中使用它呢? 难道要重写现有的基于普通索引方法的代码吗? 不! 只要你转变思想, 你就可以轻松的以元素间索引的方法思考并看待问题.</p><h2 id=实践的例子>实践的例子</h2><p>Python 中的切片可以轻松访问一个序列的子序列:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#666>&gt;&gt;&gt;</span> <span style=color:#888>[</span><span style=color:#444>3</span><span style=color:#888>,</span> <span style=color:#444>4</span><span style=color:#888>,</span> <span style=color:#444>5</span><span style=color:#888>,</span> <span style=color:#444>6</span><span style=color:#888>,</span> <span style=color:#444>3</span><span style=color:#888>][</span><span style=color:#444>2</span><span style=color:#888>:</span><span style=color:#444>4</span><span style=color:#888>]</span>
</span></span><span style=display:flex><span><span style=color:#888>[</span><span style=color:#444>5</span><span style=color:#888>,</span> <span style=color:#444>6</span><span style=color:#888>]</span>
</span></span></code></pre></div><p>切片是以左闭右开的方式进行, 例如上面的切片包含索引为 2 的元素, 不包含索引为 4 的元素. 但是, 如果你想象它使用的是元素间索引的方法, 你会发现结果也对得上! 如果切片 API 使用的是其他的表示法, 例如左开右闭, 或是全开/全闭, 那么我们就不能把思想无缝切换到元素间索引表示法了. 左闭右开的方法之所以如此流行, 或许也有这种原因, 即它体现了元素间索引的思想.</p><blockquote><p>Edsger W. Dijkstra 写过一些<a href=https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html>笔记</a>阐述了一些推荐使用左闭右开的原因.</p></blockquote><p>Python 中的负数索引有时也挺让人头大. 快速回答一下: 执行 <code>"0123456789"[-7:5]</code> 的结果是多少?</p><p>数了一会儿, 你决定写代码看结果.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#666>&gt;&gt;&gt;</span> <span style=color:#b83838>&#34;0123456789&#34;</span><span style=color:#888>[</span><span style=color:#666>-</span><span style=color:#444>7</span><span style=color:#888>:</span><span style=color:#444>5</span><span style=color:#888>]</span>
</span></span><span style=display:flex><span><span style=color:#b83838>&#39;34&#39;</span>
</span></span></code></pre></div><p>我们给它标上普通索引, 负数索引, 元素间索引:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>  -10  -9  -8  -7  -6  -5  -4  -3  -2  -1
</span></span><span style=display:flex><span>  +---+---+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
</span></span><span style=display:flex><span>  +---+---+---+---+---+---+---+---+---+---+
</span></span><span style=display:flex><span>  0   1   2   3   4   5   6   7   8   9   10
</span></span><span style=display:flex><span>-10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0
</span></span></code></pre></div><p>对于元素间索引, 从右往前从 0 开始编号而不是从 -1 开始, 这样我们可以用 <code>(-7, 5)</code> 来表示 <code>'34'</code>. 这样, 还可以轻松的把负数索引转换成正数索引, 只要加上数组长度就可以了. 例如 -7 转换为正数索引变成了 -7 + 10 = 3. 我们依旧可以用 <code>(3, 5)</code> 表示同一个范围! 类似的有 <code>(3, -5)</code>, <code>(-7, -5)</code>. 写代码时, 我们可以不必有任何思维负担, 写上这四种中的任意一种都是正确的, 即使该 API 使用的是左闭右开表示法. 或者说, 能这样做恰好是因为该 API 使用了左闭右开表示法.</p><p>C++ 中 begin(), end(), rbegin() 和 rend() 方法很常用, 其中 end() 和 rend() 分别指向尾后元素和反向尾后元素(即第一个元素前面的位置)</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>     +---+---+---+---+---+---+
</span></span><span style=display:flex><span>rend |   |   |   |   |   |   | end
</span></span><span style=display:flex><span>     +---+---+---+---+---+---+
</span></span><span style=display:flex><span>       |                   |
</span></span><span style=display:flex><span>     begin               rbegin
</span></span></code></pre></div><p>元素间索引这样思考:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>rend                     end
</span></span><span style=display:flex><span>  |                       |
</span></span><span style=display:flex><span>  +---+---+---+---+---+---+
</span></span><span style=display:flex><span>  |   |   |   |   |   |   |
</span></span><span style=display:flex><span>  +---+---+---+---+---+---+
</span></span><span style=display:flex><span>  |                       |
</span></span><span style=display:flex><span>begin                   rbegin
</span></span></code></pre></div><p>看起来整齐多了! 也更易于理解. 值得注意的是, 对 rend 和 end 解引用会引发错误. 对 begin 解引用得到的是 (begin, begin+1) 表示的元素, 对 rbegin 解引用得到的是 (rbegin-1, rbegin) 表示的元素.</p><p>有时会有特殊的需求: 将 <code>reverse_iterator</code> 转换为 <code>iterator</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#2838b0>auto</span> iter <span style=color:#666>=</span> rev_iter<span style=color:#888>.</span>base<span style=color:#888>();</span>
</span></span></code></pre></div><p>从普通索引的角度看, 实际上 iter 和 rev_iter 指向的不是一个位置:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>       rev_iter
</span></span><span style=display:flex><span>          |
</span></span><span style=display:flex><span>+---+---+---+---+---+---+
</span></span><span style=display:flex><span>|   |   |   |   |   |   |
</span></span><span style=display:flex><span>+---+---+---+---+---+---+
</span></span><span style=display:flex><span>              |
</span></span><span style=display:flex><span>            iter
</span></span></code></pre></div><p>base() 方法对 rev_iter 加了一个偏移再返回. 元素间索引这样思考:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>         rev_iter
</span></span><span style=display:flex><span>            |
</span></span><span style=display:flex><span>+---+---+---+---+---+---+
</span></span><span style=display:flex><span>|   |   |   |   |   |   |
</span></span><span style=display:flex><span>+---+---+---+---+---+---+
</span></span><span style=display:flex><span>            |
</span></span><span style=display:flex><span>          iter
</span></span></code></pre></div><p>即没有偏移. 这样, 迭代器转换就变得很自然, 只不过, 对于 iter, 解引用得到的是 (iter, iter + 1), <code>rev_iter</code> 解引用得到的是 <code>(rev_iter - 1, rev_iter)</code>.</p><h2 id=数组操作>数组操作</h2><p>对于数组处理, 元素间索引也有好处. 假设我们处理一个数组: 遍历的同时执行某种操作, 我们会使用一个索引表示处理到的位置, 这个索引左边是已处理的部分, 右边是未处理的部分. 那么索引本身指向的位置是处理过的还是未处理过的? 这有时会引发一些问题. 使用元素间索引, 我们不会再有歧义, 因为索引不再指向元素.</p><h2 id=索引从-0-开始还是从-1-开始>索引从 0 开始还是从 1 开始</h2><p>在索引从 1 开始的代码(或算法描述)和从 0 开始的代码之间转换有时会费点功夫.</p><p>假设一个数组如下所示:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>  1   2   3   4   5   6
</span></span><span style=display:flex><span>+---+---+---+---+---+---+
</span></span><span style=display:flex><span>| 0 | 1 | 2 | 3 | 4 | 5 |
</span></span><span style=display:flex><span>+---+---+---+---+---+---+
</span></span><span style=display:flex><span>0   1   2   3   4   5   6
</span></span></code></pre></div><p>如果我们始终以元素间索引的方式思考, 例如 <code>(3, 4)</code>, 如果使用从 0 索引的编程语言, 用二元组的第一个元素解引用相当于 A[3], 如果使用从 1 开始的编程语言, 用二元组的第二个元素解引用即 A[4]. 这无疑简化了思考. 即使对于元素间索引使用 1 索引法, 也会变成 <code>(4, 5)</code>, 相对于原来的 <code>(3, 4)</code>, 这也是对二元组加 1. 十分容易.</p><h2 id=总结>总结</h2><p>元素间索引的方法对于处理和理解索引相关的问题很有益.</p><h2 id=references>References</h2><ul><li><a href=https://blog.nelhage.com/2015/08/indices-point-between-elements/>Indices point between elements - Made of Bugs</a></li><li><a href=https://en.wikipedia.org/wiki/Off-by-one_error>Off-by-one error - Wikipedia</a></li><li><a href=https://en.wikipedia.org/wiki/Zero-based_numbering>Zero-based numbering - Wikipedia</a></li><li><a href=https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html>E.W. Dijkstra Archive: Why numbering should start at zero (EWD 831)</a></li></ul></div></div></section><section class=section><div class=container><aside><div id=disqus_thread></div></aside><div id=show_comments><a id=load_comments class="button is-link">Load comments</a></div><script type=text/javascript>var hash,disqus_shortname="6cdh-github-io";function disqus(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}hash=window.location.hash.substr(1),hash.length>8&&hash.substring(0,8)==="comment-"?(disqus(),document.getElementById("show_comments").style.display="none"):document.getElementById("load_comments").onclick=function(){disqus(),document.getElementById("show_comments").style.display="none"}</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div></section><section class=section><div class="container has-text-centered"><p></p><p>Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/ribice/kiss>Kiss</a>.</p></div></section></body></html>