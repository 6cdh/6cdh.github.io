<!doctype html><html xmlns=http://www.w3.org/1999/xhtml lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>C++ 模板参数推导 | 6cdh's Blog</title><meta property='og:title' content="C++ 模板参数推导 - 6cdh's Blog"><meta property='og:description' content='实例化函数模板时, 模板实参必须是已知的, 但不必显式指定. 编译器会从函数模板的实参中推导缺失的模板实参. 另外模板参数推导也可以在 auto 说明符的上下文中从初始化器推导变量的类型.'><meta property='og:url' content='https://6cdh.github.io/posts/template-argument-deduction/'><meta property='og:site_name' content="6cdh's Blog"><meta property='og:type' content='article'><meta property='og:image' content='https://www.gravatar.com/avatar/b8cddc4add92aa9aa4ad41498604c028?s=256'><meta property='article:section' content='Posts'><meta property='article:tag' content='c++'><meta property='article:tag' content='template'><meta property='article:published_time' content='2020-10-19T22:14:18Z'><meta property='article:modified_time' content='2020-10-19T22:14:18Z'><meta name=twitter:card content='summary'><meta name=twitter:site content='@'><meta name=twitter:creator content='@'><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://6cdh.github.io/custom.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://6cdh.github.io/posts/template-argument-deduction/><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"></head><body><section class=section><div class=container><nav id=nav-main class=nav><div id=nav-name class=nav-left><a id=nav-anchor class=nav-item href=https://6cdh.github.io/><h1 id=nav-heading class="title is-4">6cdh's Blog</h1></a></div><div class=nav-right><nav id=nav-items class="nav-item level is-mobile"><a class=level-item aria-label=github href=https://github.com/6cdh target=_blank rel='me noopener'><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</i></span></a><a class=level-item aria-label=email href=mailto:cd6cdh@gmail.com target=_blank rel='me noopener'><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
</i></span></a><a class=level-item aria-label=rss href=/index.xml target=_blank rel='me noopener'><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></i></span></a></nav></div></nav><nav class=nav></nav></div><script src=/js/navicon-shift.js></script></section><section class=section><div class=container><div class="subtitle tags is-6 is-pulled-right"><a class="subtitle is-6" href=/tags/c++/>#c++</a>
| <a class="subtitle is-6" href=/tags/template/>#template</a></div><h2 class="subtitle is-6">October 19, 2020</h2><h1 class=title>C++ 模板参数推导</h1><div class=content><p>实例化函数模板时, 模板实参必须是已知的, 但不必显式指定. 编译器会从函数模板的实参中推导缺失的模板实参. 另外模板参数推导也可以在 auto 说明符的上下文中从初始化器推导变量的类型.</p><h2 id=函数模板参数的推导>函数模板参数的推导</h2><p>对于下列的函数模板及其调用</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#2838b0>template</span> <span style=color:#666>&lt;</span><span style=color:#2838b0>typename</span> T<span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#2838b0;font-style:italic>void</span> f<span style=color:#888>(</span>P param<span style=color:#888>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic>// ...
</span></span></span><span style=display:flex><span><span style=color:#888;font-style:italic></span>
</span></span><span style=display:flex><span>f<span style=color:#888>(</span>A<span style=color:#888>);</span>
</span></span></code></pre></div><p>其中 P 和 T 有关, 例如 P 可能为 const T& 或 T&& 等. 有下列的推导规则:</p><ul><li>A 的引用属性被忽略.</li><li>P 是非引用时, A 的 cv 限定符被忽略.</li><li>如果 P 是无 cv 限定符的转发引用 (即 T&&), 且 A 是左值时, T 被推导为左值引用.</li><li>如果 A 是数组或函数, P 是值时, 数组和函数退化为指针. P 是引用时, 不退化为指针.</li></ul><p>这里 cv 限定符指的是 const 和 volatile.</p><p>使用下面的代码验证</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#289870>#include</span> <span style=color:#289870>&lt;cstdio&gt;</span><span style=color:#289870>
</span></span></span><span style=display:flex><span><span style=color:#289870></span>
</span></span><span style=display:flex><span><span style=color:#2838b0>template</span> <span style=color:#666>&lt;</span><span style=color:#2838b0>typename</span> T<span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#2838b0;font-style:italic>void</span> f<span style=color:#888>(</span>T param<span style=color:#888>)</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>puts<span style=color:#888>(</span>__PRETTY_FUNCTION__<span style=color:#888>);</span>
</span></span><span style=display:flex><span><span style=color:#888>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#2838b0;font-style:italic>int</span> <span style=color:#785840>main</span><span style=color:#888>()</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0;font-style:italic>int</span> i <span style=color:#666>=</span> <span style=color:#444>0</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>    f<span style=color:#888>(</span>i<span style=color:#888>);</span>
</span></span><span style=display:flex><span><span style=color:#888>}</span>
</span></span></code></pre></div><p>这个例子中 P = T, A = int. 结果是</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>void f<span style=color:#666>(</span>T<span style=color:#666>)</span> <span style=color:#666>[</span><span style=color:#b04040>T</span> <span style=color:#666>=</span> int<span style=color:#666>]</span>
</span></span></code></pre></div><p>注意 <code>__PRETTY_FUNCTION__</code> 是编译器扩展, 在 gcc 和 clang 中支持, 在 MSVC 中可以使用 <code>__FUNCSIG__</code>.</p><p>下面是一个经过实验的表格</p><table><thead><tr><th style=text-align:center>P</th><th style=text-align:center>A</th><th style=text-align:center>T</th></tr></thead><tbody><tr><td style=text-align:center>T</td><td style=text-align:center>int</td><td style=text-align:center>int</td></tr><tr><td style=text-align:center>T</td><td style=text-align:center>int*</td><td style=text-align:center>int*</td></tr><tr><td style=text-align:center>T</td><td style=text-align:center>int&</td><td style=text-align:center>int</td></tr><tr><td style=text-align:center>T</td><td style=text-align:center>const int</td><td style=text-align:center>int</td></tr><tr><td style=text-align:center>T</td><td style=text-align:center>const int *</td><td style=text-align:center>const int *</td></tr><tr><td style=text-align:center>T</td><td style=text-align:center>int * const</td><td style=text-align:center>int *</td></tr><tr><td style=text-align:center>T</td><td style=text-align:center>const int &</td><td style=text-align:center>int</td></tr><tr><td style=text-align:center>T</td><td style=text-align:center>const int * const</td><td style=text-align:center>const int *</td></tr><tr><td style=text-align:center>T</td><td style=text-align:center>char [2]</td><td style=text-align:center>char *</td></tr><tr><td style=text-align:center>T</td><td style=text-align:center>const char [12]</td><td style=text-align:center>const char *</td></tr><tr><td style=text-align:center>T</td><td style=text-align:center>void (int)</td><td style=text-align:center>void (*)(int)</td></tr><tr><td style=text-align:center>const T</td><td style=text-align:center>int</td><td style=text-align:center>int</td></tr><tr><td style=text-align:center>const T</td><td style=text-align:center>int *</td><td style=text-align:center>int *</td></tr><tr><td style=text-align:center>const T</td><td style=text-align:center>int &</td><td style=text-align:center>int</td></tr><tr><td style=text-align:center>const T</td><td style=text-align:center>const int</td><td style=text-align:center>int</td></tr><tr><td style=text-align:center>const T</td><td style=text-align:center>const int *</td><td style=text-align:center>const int *</td></tr><tr><td style=text-align:center>const T</td><td style=text-align:center>const int &</td><td style=text-align:center>int</td></tr><tr><td style=text-align:center>const T</td><td style=text-align:center>const int * const</td><td style=text-align:center>const int *</td></tr><tr><td style=text-align:center>const T</td><td style=text-align:center>char [2]</td><td style=text-align:center>char *</td></tr><tr><td style=text-align:center>const T</td><td style=text-align:center>const char [12]</td><td style=text-align:center>const char *</td></tr><tr><td style=text-align:center>const T</td><td style=text-align:center>void (int)</td><td style=text-align:center>void (*)(int)</td></tr><tr><td style=text-align:center>T&</td><td style=text-align:center>int</td><td style=text-align:center>int</td></tr><tr><td style=text-align:center>T&</td><td style=text-align:center>int *</td><td style=text-align:center>int *</td></tr><tr><td style=text-align:center>T&</td><td style=text-align:center>int &</td><td style=text-align:center>int</td></tr><tr><td style=text-align:center>T&</td><td style=text-align:center>const int</td><td style=text-align:center>const int</td></tr><tr><td style=text-align:center>T&</td><td style=text-align:center>const int *</td><td style=text-align:center>const int *</td></tr><tr><td style=text-align:center>T&</td><td style=text-align:center>const int &</td><td style=text-align:center>const int</td></tr><tr><td style=text-align:center>T&</td><td style=text-align:center>const int * const</td><td style=text-align:center>const int * const</td></tr><tr><td style=text-align:center>T&</td><td style=text-align:center>char [2]</td><td style=text-align:center>char [2]</td></tr><tr><td style=text-align:center>T&</td><td style=text-align:center>const char [12]</td><td style=text-align:center>const char [12]</td></tr><tr><td style=text-align:center>T&</td><td style=text-align:center>void (int)</td><td style=text-align:center>void (int)</td></tr><tr><td style=text-align:center>T&&</td><td style=text-align:center>int</td><td style=text-align:center>int &</td></tr><tr><td style=text-align:center>T&&</td><td style=text-align:center>int *</td><td style=text-align:center>int *&</td></tr><tr><td style=text-align:center>T&&</td><td style=text-align:center>int &</td><td style=text-align:center>int &</td></tr><tr><td style=text-align:center>T&&</td><td style=text-align:center>const int</td><td style=text-align:center>const int &</td></tr><tr><td style=text-align:center>T&&</td><td style=text-align:center>const int *</td><td style=text-align:center>const int *&</td></tr><tr><td style=text-align:center>T&&</td><td style=text-align:center>const int &</td><td style=text-align:center>const int &</td></tr><tr><td style=text-align:center>T&&</td><td style=text-align:center>const int * const</td><td style=text-align:center>const int * const &</td></tr><tr><td style=text-align:center>T&&</td><td style=text-align:center>char [2]</td><td style=text-align:center>char (&)[2]</td></tr><tr><td style=text-align:center>T&&</td><td style=text-align:center>const char [12]</td><td style=text-align:center>const char (&)[12]</td></tr><tr><td style=text-align:center>T&&</td><td style=text-align:center>void (int)</td><td style=text-align:center>void (&)(int)</td></tr><tr><td style=text-align:center>T&&</td><td style=text-align:center>int &&</td><td style=text-align:center>int</td></tr><tr><td style=text-align:center>const T&</td><td style=text-align:center>int &&</td><td style=text-align:center>int</td></tr></tbody></table><h2 id=auto-类型推导>auto 类型推导</h2><p>C++11 中, 对于包含 auto 的变量声明, auto 被一个虚构的模板参数 U 替换, 实参 A 是初始化表达式, 按照模板参数推导的规则从 P 和 A 推导出 U 后, 将 U 代入 P 得到实际的变量类型.</p><p>例如</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#2838b0>const</span> <span style=color:#2838b0>auto</span><span style=color:#666>&amp;</span> x <span style=color:#666>=</span> <span style=color:#444>1</span> <span style=color:#666>+</span> <span style=color:#444>2</span><span style=color:#888>;</span>
</span></span></code></pre></div><p>用 U 替换 auto, 得到</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#2838b0>const</span> U<span style=color:#666>&amp;</span> x <span style=color:#666>=</span> <span style=color:#444>1</span> <span style=color:#666>+</span> <span style=color:#444>2</span><span style=color:#888>;</span>
</span></span></code></pre></div><p>这里 P 是 const U&, A 是 1 + 2, A 的类型为 int, 使用模板参数推导的规则, U 是 int, 因此变量 x 的类型为 const int &.</p><p>auto 类型推导基本与模板参数推导相同, 不同的一点是如果 A 是拷贝列表初始化, 则 U 被替换为 <code>std::initializer_list&lt;U></code>.</p><h2 id=函数返回类型推导>函数返回类型推导</h2><p>C++14 中, 对于返回 auto 的函数, auto 被一个虚构的模板参数 U 替换, 参数 A 是 return 语句的表达式, 如果 return 语句没有操作数, A 为 void(). 使用上面的规则推导 U, 然后获得实际的返回类型.</p><p>例如</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#2838b0>auto</span> <span style=color:#785840>f</span><span style=color:#888>()</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>return</span> <span style=color:#444>42</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span><span style=color:#888>}</span>
</span></span></code></pre></div><p>其中 A 是 42, 类型为 int. 因此 U 被推导为 int, 函数返回类型也为 int.</p><p>如果返回语句是 <code>return;</code> 或没有返回语句, A 被认为是 void(). 因此, 下面的函数</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#2838b0>auto</span> <span style=color:#785840>f</span><span style=color:#888>()</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>return</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span><span style=color:#888>}</span>
</span></span></code></pre></div><p>的返回类型为 void.</p><p>对于下面的函数</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#888;font-style:italic>// C++14
</span></span></span><span style=display:flex><span><span style=color:#888;font-style:italic></span><span style=color:#289870>#include</span> <span style=color:#289870>&lt;type_traits&gt;</span><span style=color:#289870>
</span></span></span><span style=display:flex><span><span style=color:#289870></span>
</span></span><span style=display:flex><span><span style=color:#2838b0>const</span> <span style=color:#2838b0>auto</span> <span style=color:#785840>f</span><span style=color:#888>()</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>return</span> <span style=color:#444>42</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span><span style=color:#888>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#2838b0>static_assert</span><span style=color:#888>(</span>std<span style=color:#666>::</span>is_same<span style=color:#666>&lt;</span><span style=color:#2838b0>decltype</span><span style=color:#888>(</span>f<span style=color:#888>()),</span> <span style=color:#2838b0>const</span> <span style=color:#2838b0;font-style:italic>int</span><span style=color:#666>&gt;::</span>value<span style=color:#888>,</span> <span style=color:#b83838>&#34;error&#34;</span><span style=color:#888>);</span>
</span></span></code></pre></div><p>如果按照模板参数推导的规则, 函数 f 的返回值应该是 const int. 但是上面的 static_cast 会失败:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>error: static_assert failed due to requirement <span style=color:#b83838>&#39;std::is_same&lt;int, const int&gt;::value&#39;</span> <span style=color:#b83838>&#34;error&#34;</span>
</span></span></code></pre></div><p>看起来 f 的返回类型实际上是 int. 这是由于非引用类型的函数返回值是纯右值, 而非类非数组的纯右值不能被 cv 限定, 因此虽然 f 的返回类型是 const int, 但它的 const 属性会被立刻剥离.</p><p>如果有多条 return 语句, 上述规则会对每条 return 语句执行, 如果它们的实际返回类型不同, 会引发编译错误.</p><h2 id=类模板参数推导-class-template-argument-deduction-ctad>类模板参数推导 <em>(Class template argument deduction, CTAD)</em></h2><p>C++17 将模板参数推导扩展到了仅给出类模板名称的对象构造. 例如</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#289870>#include</span> <span style=color:#289870>&lt;type_traits&gt;</span><span style=color:#289870>
</span></span></span><span style=display:flex><span><span style=color:#289870>#include</span> <span style=color:#289870>&lt;utility&gt;</span><span style=color:#289870>
</span></span></span><span style=display:flex><span><span style=color:#289870></span>
</span></span><span style=display:flex><span><span style=color:#2838b0;font-style:italic>int</span> <span style=color:#785840>main</span><span style=color:#888>()</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>    std<span style=color:#666>::</span>pair p<span style=color:#888>{</span><span style=color:#444>0</span><span style=color:#888>,</span> <span style=color:#444>0.0</span><span style=color:#888>};</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>static_assert</span><span style=color:#888>(</span>std<span style=color:#666>::</span>is_same_v<span style=color:#666>&lt;</span><span style=color:#2838b0>decltype</span><span style=color:#888>(</span>p<span style=color:#888>),</span> std<span style=color:#666>::</span>pair<span style=color:#666>&lt;</span><span style=color:#2838b0;font-style:italic>int</span><span style=color:#888>,</span> <span style=color:#2838b0;font-style:italic>double</span><span style=color:#666>&gt;&gt;</span><span style=color:#888>);</span>
</span></span><span style=display:flex><span><span style=color:#888>}</span>
</span></span></code></pre></div><p>p 会被推导为 <code>std::pair&lt;int, double></code>. static_assert 验证了这点.</p><h2 id=推导指引>推导指引</h2><p>如果构造函数是模板函数, CTAD 不会工作. 因此 C++17 也允许使用推导指引 <em>(deduction guide)</em>. 它指示编译器如何从构造函数模板的参数中推导类模板参数.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#289870>#include</span> <span style=color:#289870>&lt;iterator&gt;</span><span style=color:#289870>
</span></span></span><span style=display:flex><span><span style=color:#289870></span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic>// declaration of the template
</span></span></span><span style=display:flex><span><span style=color:#888;font-style:italic></span><span style=color:#2838b0>template</span> <span style=color:#666>&lt;</span><span style=color:#2838b0>typename</span> T<span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#2838b0>struct</span> <span style=color:#287088>container</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>    container<span style=color:#888>(</span>T t<span style=color:#888>)</span> <span style=color:#888>{}</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>template</span> <span style=color:#666>&lt;</span><span style=color:#2838b0>typename</span> Iter<span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span>    container<span style=color:#888>(</span>Iter beg<span style=color:#888>,</span> Iter end<span style=color:#888>);</span>
</span></span><span style=display:flex><span><span style=color:#888>};</span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic>// additional deduction guide
</span></span></span><span style=display:flex><span><span style=color:#888;font-style:italic></span><span style=color:#2838b0>template</span> <span style=color:#666>&lt;</span><span style=color:#2838b0>typename</span> Iter<span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span>container<span style=color:#888>(</span>Iter b<span style=color:#888>,</span> Iter e<span style=color:#888>)</span>
</span></span><span style=display:flex><span>    <span style=color:#666>-&gt;</span> container<span style=color:#666>&lt;</span><span style=color:#2838b0>typename</span> std<span style=color:#666>::</span>iterator_traits<span style=color:#666>&lt;</span>Iter<span style=color:#666>&gt;::</span>value_type<span style=color:#666>&gt;</span><span style=color:#888>;</span>
</span></span></code></pre></div><p>注意推导指引不能放在类中构造函数的定义后面, 因为这会被认为是尾置返回类型继而引发编译错误.</p><h2 id=references>References</h2><ul><li><a href=https://en.cppreference.com/w/cpp/language/class_template_argument_deduction>Class template argument deduction (CTAD) (since C++17) - cppreference.com</a></li><li><a href=https://devblogs.microsoft.com/cppblog/how-to-use-class-template-argument-deduction/>How to Use Class Template Argument Deduction | C++ Team Blog</a></li><li>Effective Modern C++</li><li><a href=https://en.cppreference.com/w/cpp/language/value_category>Value categories - cppreference.com</a></li></ul></div></div></section><section class=section><div class=container><aside><div id=disqus_thread></div></aside><div id=show_comments><a id=load_comments class="button is-link">Load comments</a></div><script type=text/javascript>var hash,disqus_shortname="6cdh-github-io";function disqus(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}hash=window.location.hash.substr(1),hash.length>8&&hash.substring(0,8)==="comment-"?(disqus(),document.getElementById("show_comments").style.display="none"):document.getElementById("load_comments").onclick=function(){disqus(),document.getElementById("show_comments").style.display="none"}</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div></section><section class=section><div class="container has-text-centered"><p></p><p>Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/ribice/kiss>Kiss</a>.</p></div></section></body></html>