<!doctype html><html xmlns=http://www.w3.org/1999/xhtml lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>The Welfare Crook | 6cdh's Blog</title><meta property='og:title' content="The Welfare Crook - 6cdh's Blog"><meta property='og:description' content='题目 The Welfare Crook, 出自 &ldquo;Science of Programming&rdquo;:

Suppose we have three long magnetic tapes, each containing a list of names in alphabetical order. The first list contains the names of people woring at IBM Yorktown, the second the names of students at Columbia University and the third the names of people on welfare in New York City. Practically speaking, all three lists are endless, so no upper bounds are given. It is known that at least one person is on all three lists. Write a program to locate the first such person (the one with the alphabetically smallest person).'><meta property='og:url' content='https://6cdh.github.io/posts/the-welfare-crook/'><meta property='og:site_name' content="6cdh's Blog"><meta property='og:type' content='article'><meta property='og:image' content='https://www.gravatar.com/avatar/b8cddc4add92aa9aa4ad41498604c028?s=256'><meta property='article:section' content='Posts'><meta property='article:tag' content='algorithm'><meta property='article:tag' content='program verification'><meta property='article:published_time' content='2021-01-21T20:52:12Z'><meta property='article:modified_time' content='2021-01-21T20:52:12Z'><meta name=twitter:card content='summary'><meta name=twitter:site content='@'><meta name=twitter:creator content='@'><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://6cdh.github.io/custom.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://6cdh.github.io/posts/the-welfare-crook/><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"></head><body><section class=section><div class=container><nav id=nav-main class=nav><div id=nav-name class=nav-left><a id=nav-anchor class=nav-item href=https://6cdh.github.io/><h1 id=nav-heading class="title is-4">6cdh's Blog</h1></a></div><div class=nav-right><nav id=nav-items class="nav-item level is-mobile"><a class=level-item aria-label=github href=https://github.com/6cdh target=_blank rel='me noopener'><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</i></span></a><a class=level-item aria-label=email href=mailto:cd6cdh@gmail.com target=_blank rel='me noopener'><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
</i></span></a><a class=level-item aria-label=rss href=/index.xml target=_blank rel='me noopener'><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></i></span></a></nav></div></nav><nav class=nav></nav></div><script src=/js/navicon-shift.js></script></section><section class=section><div class=container><div class="subtitle tags is-6 is-pulled-right"><a class="subtitle is-6" href=/tags/algorithm/>#algorithm</a>
| <a class="subtitle is-6" href=/tags/program-verification/>#program verification</a></div><h2 class="subtitle is-6">January 21, 2021</h2><h1 class=title>The Welfare Crook</h1><div class=content><p>题目 The Welfare Crook, 出自 &ldquo;Science of Programming&rdquo;:</p><blockquote><p>Suppose we have three long magnetic tapes, each containing a list of names in alphabetical order. The first list contains the names of people woring at IBM Yorktown, the second the names of students at Columbia University and the third the names of people on welfare in New York City. Practically speaking, all three lists are endless, so no upper bounds are given. It is known that at least one person is on all three lists. Write a program to locate the first such person (the one with the alphabetically smallest person).</p></blockquote><p>这个题目看起来不太容易, 而且可能需要几十行代码, 如果不使用形式化方法的话.</p><p>假设这三个列表分别表示为 f, g, h. 最后找到的位置是 iv, jv, kv. 这样, 我们有了后置条件:</p><p>$$
R: 0\le \text{iv}\land 0\le \text{jv}\land 0\le \text{kv}\land f[\text{iv}] = g[\text{jv}] = h[\text{kv}]
$$</p><p>为了编写循环, 使用 i, j, k 替换 iv, jv, kv, 并弱化谓词, 得到不变式:</p><p>$$
P: 0\le i\le \text{iv}\land 0\le j\le \text{jv}\land 0\le k\le \text{kv}
$$</p><p>显然, 我们需要迭代三个变量 i, j, k, 在满足某些情况时, 递增某个变量. 最简单的递增方法就是递增 1:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#2838b0>def</span> <span style=color:#785840>the_welfare_crook</span><span style=color:#888>(</span>f<span style=color:#888>,</span> g<span style=color:#888>,</span> h<span style=color:#888>)</span> <span style=color:#666>-&gt;</span> <span style=color:#388038>str</span><span style=color:#888>:</span>
</span></span><span style=display:flex><span>    i<span style=color:#888>,</span> j<span style=color:#888>,</span> k <span style=color:#666>=</span> <span style=color:#444>0</span><span style=color:#888>,</span> <span style=color:#444>0</span><span style=color:#888>,</span> <span style=color:#444>0</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>while</span> f<span style=color:#888>[</span>i<span style=color:#888>]</span> <span style=color:#666>!=</span> g<span style=color:#888>[</span>j<span style=color:#888>]</span> <span style=color:#a848a8>or</span> f<span style=color:#888>[</span>i<span style=color:#888>]</span> <span style=color:#666>!=</span> h<span style=color:#888>[</span>k<span style=color:#888>]:</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>if</span> IF1<span style=color:#888>:</span>
</span></span><span style=display:flex><span>            i <span style=color:#666>=</span> i <span style=color:#666>+</span> <span style=color:#444>1</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>if</span> IF2<span style=color:#888>:</span>
</span></span><span style=display:flex><span>            j <span style=color:#666>=</span> j <span style=color:#666>+</span> <span style=color:#444>1</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>if</span> IF3<span style=color:#888>:</span>
</span></span><span style=display:flex><span>            k <span style=color:#666>=</span> k <span style=color:#666>+</span> <span style=color:#444>1</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>return</span> f<span style=color:#888>[</span>i<span style=color:#888>]</span>
</span></span></code></pre></div><p>接下来需要确定 IF1, IF2, IF3. 首先看看 IF1: (这里使用了 predicate transformer 来推导 IF1 的最弱形式)</p><p>$$
\begin{aligned}
\text{IF1} & = \text{wp}(&ldquo;i := i + 1&rdquo;, P)\cr
& = 0\le i+1\le \text{iv}\land 0\le j\le \text{jv}\land 0\le k\le \text{kv}\cr
& = 0\le i + 1\le \text{iv}\cr
& = i &lt; \text{iv}
\end{aligned}
$$</p><p>所以只要满足 i &lt; iv 即可递增 i. 问题在于 iv 就是我们想要找到的结果, 现在是未知的. 我们可以换个思路, 现在已知的有 i, j, k, f[i], g[j], h[k], 只要 f[i] &lt; g[j] $\lor$ f[i] &lt; h[k] 就一定意味着 i &lt; iv, 反之则不一定. 因此</p><p>$$
\text{IF1} = f[i] &lt; g[j]\land f[i] &lt; h[k]
$$</p><p>同理, 推导出 IF2 和 IF3:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#2838b0>def</span> <span style=color:#785840>the_welfare_crook</span><span style=color:#888>(</span>f<span style=color:#888>,</span> g<span style=color:#888>,</span> h<span style=color:#888>)</span> <span style=color:#666>-&gt;</span> <span style=color:#388038>str</span><span style=color:#888>:</span>
</span></span><span style=display:flex><span>    i<span style=color:#888>,</span> j<span style=color:#888>,</span> k <span style=color:#666>=</span> <span style=color:#444>0</span><span style=color:#888>,</span> <span style=color:#444>0</span><span style=color:#888>,</span> <span style=color:#444>0</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>while</span> f<span style=color:#888>[</span>i<span style=color:#888>]</span> <span style=color:#666>!=</span> g<span style=color:#888>[</span>j<span style=color:#888>]</span> <span style=color:#a848a8>or</span> f<span style=color:#888>[</span>i<span style=color:#888>]</span> <span style=color:#666>!=</span> h<span style=color:#888>[</span>k<span style=color:#888>]:</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>if</span> f<span style=color:#888>[</span>i<span style=color:#888>]</span> <span style=color:#666>&lt;</span> g<span style=color:#888>[</span>j<span style=color:#888>]</span> <span style=color:#a848a8>or</span> f<span style=color:#888>[</span>i<span style=color:#888>]</span> <span style=color:#666>&lt;</span> h<span style=color:#888>[</span>k<span style=color:#888>]:</span>
</span></span><span style=display:flex><span>            i <span style=color:#666>=</span> i <span style=color:#666>+</span> <span style=color:#444>1</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>if</span> g<span style=color:#888>[</span>j<span style=color:#888>]</span> <span style=color:#666>&lt;</span> f<span style=color:#888>[</span>i<span style=color:#888>]</span> <span style=color:#a848a8>or</span> g<span style=color:#888>[</span>j<span style=color:#888>]</span> <span style=color:#666>&lt;</span> h<span style=color:#888>[</span>k<span style=color:#888>]:</span>
</span></span><span style=display:flex><span>            j <span style=color:#666>=</span> j <span style=color:#666>+</span> <span style=color:#444>1</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>if</span> h<span style=color:#888>[</span>k<span style=color:#888>]</span> <span style=color:#666>&lt;</span> f<span style=color:#888>[</span>i<span style=color:#888>]</span> <span style=color:#a848a8>or</span> h<span style=color:#888>[</span>k<span style=color:#888>]</span> <span style=color:#666>&lt;</span> g<span style=color:#888>[</span>j<span style=color:#888>]:</span>
</span></span><span style=display:flex><span>            k <span style=color:#666>=</span> k <span style=color:#666>+</span> <span style=color:#444>1</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>return</span> f<span style=color:#888>[</span>i<span style=color:#888>]</span>
</span></span></code></pre></div><p>这样不变式得到了维护. 下面需要证明循环会终止. 令整数函数 t = iv - i + jv - j + kv - k, 显然 t 每次循环都会减小, 且 t 有下界 0. 因此循环一定会终止.</p><p>下面证明如果循环终止, R 成立. 令循环条件为 BB, 首先需要证明 BB 是循环中各种条件的析取 (因为 IF1, IF2, IF3 需要覆盖 BB 成立的条件下的所有可能).</p><p>$$
\begin{aligned}
\text{IF1}\lor \text{IF2}\lor \text{IF3} & = f[i] &lt; g[j] \lor f[i] &lt; h[k]\cr
& \lor g[j] &lt; f[i] \lor g[j] &lt; h[k]\cr
& \lor h[k] &lt; f[i] \lor h[k] &lt; g[j]\cr
& = f[i] \not= g[j]\lor f[i] \not= h[k]\cr
& = \text{BB}
\end{aligned}
$$</p><p>另外, 需要证明 P $\land \neg $ BB $\Rightarrow$ R:</p><p>$$
\begin{aligned}
& P\land \neg \text{BB}\cr
& = P\land \neg (f[i]\not= g[j]\lor f[i]\not= h[k])\cr
& = P\land f[i]=g[j]=h[k]\cr
& = R
\end{aligned}
$$</p><p>这样, 我们证明了程序是正确的. 不过现在的条件判断太多了, 我们可以用更少的条件来证明 BB 是三个条件的析取. 经过仔细研究发现可以去掉一半:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#2838b0>if</span> f<span style=color:#888>[</span>i<span style=color:#888>]</span> <span style=color:#666>&lt;</span> g<span style=color:#888>[</span>j<span style=color:#888>]:</span>
</span></span><span style=display:flex><span>    i <span style=color:#666>=</span> i <span style=color:#666>+</span> <span style=color:#444>1</span>
</span></span><span style=display:flex><span><span style=color:#2838b0>if</span> g<span style=color:#888>[</span>j<span style=color:#888>]</span> <span style=color:#666>&lt;</span> h<span style=color:#888>[</span>k<span style=color:#888>]:</span>
</span></span><span style=display:flex><span>    j <span style=color:#666>=</span> j <span style=color:#666>+</span> <span style=color:#444>1</span>
</span></span><span style=display:flex><span><span style=color:#2838b0>if</span> h<span style=color:#888>[</span>k<span style=color:#888>]</span> <span style=color:#666>&lt;</span> f<span style=color:#888>[</span>i<span style=color:#888>]:</span>
</span></span><span style=display:flex><span>    k <span style=color:#666>=</span> k <span style=color:#666>+</span> <span style=color:#444>1</span>
</span></span></code></pre></div><p>因为三个条件互斥, 最后得到:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#2838b0>def</span> <span style=color:#785840>the_welfare_crook</span><span style=color:#888>(</span>f<span style=color:#888>,</span> g<span style=color:#888>,</span> h<span style=color:#888>)</span> <span style=color:#666>-&gt;</span> <span style=color:#388038>str</span><span style=color:#888>:</span>
</span></span><span style=display:flex><span>    i<span style=color:#888>,</span> j<span style=color:#888>,</span> k <span style=color:#666>=</span> <span style=color:#444>0</span><span style=color:#888>,</span> <span style=color:#444>0</span><span style=color:#888>,</span> <span style=color:#444>0</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>while</span> <span style=color:#444;font-style:italic>True</span><span style=color:#888>:</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>if</span> f<span style=color:#888>[</span>i<span style=color:#888>]</span> <span style=color:#666>&lt;</span> g<span style=color:#888>[</span>j<span style=color:#888>]:</span>
</span></span><span style=display:flex><span>            i <span style=color:#666>=</span> i <span style=color:#666>+</span> <span style=color:#444>1</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>elif</span> g<span style=color:#888>[</span>j<span style=color:#888>]</span> <span style=color:#666>&lt;</span> h<span style=color:#888>[</span>k<span style=color:#888>]:</span>
</span></span><span style=display:flex><span>            j <span style=color:#666>=</span> j <span style=color:#666>+</span> <span style=color:#444>1</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>elif</span> h<span style=color:#888>[</span>k<span style=color:#888>]</span> <span style=color:#666>&lt;</span> f<span style=color:#888>[</span>i<span style=color:#888>]:</span>
</span></span><span style=display:flex><span>            k <span style=color:#666>=</span> k <span style=color:#666>+</span> <span style=color:#444>1</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>else</span><span style=color:#888>:</span>
</span></span><span style=display:flex><span>            <span style=color:#2838b0>break</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>return</span> f<span style=color:#888>[</span>i<span style=color:#888>]</span>
</span></span></code></pre></div><p>最后的代码十分简单, 但是如果不使用形式化的方法, 几乎很难得到这样的代码, 甚至给出现成的答案也很难理解.</p><h2 id=references>References</h2><ul><li>Science of Programming</li></ul></div></div></section><section class=section><div class=container><aside><div id=disqus_thread></div></aside><div id=show_comments><a id=load_comments class="button is-link">Load comments</a></div><script type=text/javascript>var hash,disqus_shortname="6cdh-github-io";function disqus(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}hash=window.location.hash.substr(1),hash.length>8&&hash.substring(0,8)==="comment-"?(disqus(),document.getElementById("show_comments").style.display="none"):document.getElementById("load_comments").onclick=function(){disqus(),document.getElementById("show_comments").style.display="none"}</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div></section><section class=section><div class="container has-text-centered"><p></p><p>Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/ribice/kiss>Kiss</a>.</p></div></section></body></html>