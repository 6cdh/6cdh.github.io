<!doctype html><html xmlns=http://www.w3.org/1999/xhtml lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>二分搜索及其变种 | 6cdh's Blog</title><meta property='og:title' content="二分搜索及其变种 - 6cdh's Blog"><meta property='og:description' content='二分搜索 (binary search) 也称折半搜索 (half-interval search), 用于在有序数组上搜索给定值的位置. 这是一个常见的搜索算法, 似乎没什么难度. 然而, 在解决 Leetcode 35 (Search Insert Position) 时, 我意识到对二分搜索及其变种的理解还不够, 因此记录一下.'><meta property='og:url' content='https://6cdh.github.io/posts/binary_search/'><meta property='og:site_name' content="6cdh's Blog"><meta property='og:type' content='article'><meta property='og:image' content='https://www.gravatar.com/avatar/b8cddc4add92aa9aa4ad41498604c028?s=256'><meta property='article:section' content='Posts'><meta property='article:tag' content='c++'><meta property='article:tag' content='binary search'><meta property='article:published_time' content='2020-09-23T02:52:13Z'><meta property='article:modified_time' content='2020-09-23T02:52:13Z'><meta name=twitter:card content='summary'><meta name=twitter:site content='@'><meta name=twitter:creator content='@'><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://6cdh.github.io/custom.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://6cdh.github.io/posts/binary_search/><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"></head><body><section class=section><div class=container><nav id=nav-main class=nav><div id=nav-name class=nav-left><a id=nav-anchor class=nav-item href=https://6cdh.github.io/><h1 id=nav-heading class="title is-4">6cdh's Blog</h1></a></div><div class=nav-right><nav id=nav-items class="nav-item level is-mobile"><a class=level-item aria-label=github href=https://github.com/6cdh target=_blank rel='me noopener'><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg>
</i></span></a><a class=level-item aria-label=email href=mailto:cd6cdh@gmail.com target=_blank rel='me noopener'><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg>
</i></span></a><a class=level-item aria-label=rss href=/index.xml target=_blank rel='me noopener'><span class=icon><i><svg viewbox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" aria-hidden="true"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></i></span></a></nav></div></nav><nav class=nav></nav></div><script src=/js/navicon-shift.js></script></section><section class=section><div class=container><div class="subtitle tags is-6 is-pulled-right"><a class="subtitle is-6" href=/tags/c++/>#c++</a>
| <a class="subtitle is-6" href=/tags/binary-search/>#binary search</a></div><h2 class="subtitle is-6">September 23, 2020</h2><h1 class=title>二分搜索及其变种</h1><div class=content><p>二分搜索 <em>(binary search)</em> 也称折半搜索 <em>(half-interval search)</em>, 用于在有序数组上搜索给定值的位置. 这是一个常见的搜索算法, 似乎没什么难度. 然而, 在解决 <a href=https://leetcode.com/problems/search-insert-position/>Leetcode 35 (Search Insert Position)</a> 时, 我意识到对二分搜索及其变种的理解还不够, 因此记录一下.</p><h2 id=基本的二分搜索>基本的二分搜索</h2><p>搜索算法对于一个给定的非降序输入数组和一个给定的目标值, 搜索目标值所在的位置. 二分搜索首先搜索数组中点. 如果中点值大于目标值, 说明目标值在数组左半边, 这样就将输入数组缩小了一半. 如果中点的值小于目标值, 说明目标值在数组右半边, 否则, 中点值等于目标值, 返回. 重复以上步骤.</p><p>根据上面的思路得到了基本的二分搜索的 C++ 代码, 称为 <code>binary_search_v1</code> (version 1).</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#2838b0>template</span> <span style=color:#666>&lt;</span><span style=color:#2838b0>typename</span> Container<span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#2838b0;font-style:italic>int</span> binary_search_v1<span style=color:#888>(</span><span style=color:#2838b0>const</span> Container<span style=color:#666>&amp;</span> arr<span style=color:#888>,</span>
</span></span><span style=display:flex><span>                     <span style=color:#2838b0>const</span> <span style=color:#2838b0>typename</span> Container<span style=color:#666>::</span>value_type<span style=color:#666>&amp;</span> target<span style=color:#888>)</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0;font-style:italic>int</span> left <span style=color:#666>=</span> <span style=color:#444>0</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0;font-style:italic>int</span> right <span style=color:#666>=</span> arr<span style=color:#888>.</span>size<span style=color:#888>()</span> <span style=color:#666>-</span> <span style=color:#444>1</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>while</span> <span style=color:#888>(</span>left <span style=color:#666>&lt;=</span> right<span style=color:#888>)</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0;font-style:italic>int</span> mid <span style=color:#666>=</span> left <span style=color:#666>+</span> <span style=color:#888>(</span>right <span style=color:#666>-</span> left<span style=color:#888>)</span> <span style=color:#666>/</span> <span style=color:#444>2</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>if</span> <span style=color:#888>(</span>arr<span style=color:#888>[</span>mid<span style=color:#888>]</span> <span style=color:#666>&lt;</span> target<span style=color:#888>)</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>            left <span style=color:#666>=</span> mid <span style=color:#666>+</span> <span style=color:#444>1</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#888>}</span> <span style=color:#2838b0>else</span> <span style=color:#785840>if</span> <span style=color:#888>(</span>arr<span style=color:#888>[</span>mid<span style=color:#888>]</span> <span style=color:#666>&gt;</span> target<span style=color:#888>)</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>            right <span style=color:#666>=</span> mid <span style=color:#666>-</span> <span style=color:#444>1</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#888>}</span> <span style=color:#2838b0>else</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>            <span style=color:#2838b0>return</span> mid<span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#888>}</span>
</span></span><span style=display:flex><span>    <span style=color:#888>}</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>return</span> <span style=color:#666>-</span><span style=color:#444>1</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span><span style=color:#888>}</span>
</span></span></code></pre></div><p>注意上面的代码的正确性依赖于它使用的索引是有符号类型 (int). 对于过大的输入数组, 该算法可能不能正常工作. 因为 C++ 中容器大小的类型通常是 <code>std::size_t</code>, 而 <code>std::size_t</code> 是无符号类型, 特别是对于 64 位系统, <code>std::size_t</code> 通常是 64 位, 使用 32 位有符号的 int 保存它会导致溢出.</p><p><code>binary_search_v1</code> 可以用于伪代码以表示二分搜索的思想. 也可以进行略微改写以使它支持无符号类型并防止溢出:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#289870>#include</span> <span style=color:#289870>&lt;optional&gt;</span><span style=color:#289870>
</span></span></span><span style=display:flex><span><span style=color:#289870></span>
</span></span><span style=display:flex><span><span style=color:#2838b0>template</span> <span style=color:#666>&lt;</span><span style=color:#2838b0>typename</span> Container<span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span>std<span style=color:#666>::</span>optional<span style=color:#666>&lt;</span>size_t<span style=color:#666>&gt;</span> binary_search_v1_plus<span style=color:#888>(</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>const</span> Container<span style=color:#666>&amp;</span> arr<span style=color:#888>,</span> <span style=color:#2838b0>const</span> <span style=color:#2838b0>typename</span> Container<span style=color:#666>::</span>value_type<span style=color:#666>&amp;</span> target<span style=color:#888>)</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>    size_t left <span style=color:#666>=</span> <span style=color:#444>0</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>    size_t right <span style=color:#666>=</span> arr<span style=color:#888>.</span>size<span style=color:#888>();</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>while</span> <span style=color:#888>(</span>left <span style=color:#666>&lt;</span> right<span style=color:#888>)</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>        size_t mid <span style=color:#666>=</span> left <span style=color:#666>+</span> <span style=color:#888>(</span>right <span style=color:#666>-</span> left<span style=color:#888>)</span> <span style=color:#666>/</span> <span style=color:#444>2</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>if</span> <span style=color:#888>(</span>arr<span style=color:#888>[</span>mid<span style=color:#888>]</span> <span style=color:#666>&lt;</span> target<span style=color:#888>)</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>            left <span style=color:#666>=</span> mid <span style=color:#666>+</span> <span style=color:#444>1</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#888>}</span> <span style=color:#2838b0>else</span> <span style=color:#785840>if</span> <span style=color:#888>(</span>arr<span style=color:#888>[</span>mid<span style=color:#888>]</span> <span style=color:#666>&gt;</span> target<span style=color:#888>)</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>            right <span style=color:#666>=</span> mid<span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#888>}</span> <span style=color:#2838b0>else</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>            <span style=color:#2838b0>return</span> mid<span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#888>}</span>
</span></span><span style=display:flex><span>    <span style=color:#888>}</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>return</span> <span style=color:#888>{};</span>
</span></span><span style=display:flex><span><span style=color:#888>}</span>
</span></span></code></pre></div><h2 id=查找最左边的元素>查找最左边的元素</h2><p>如果数组中有多个目标值, 要求找到最左边的目标值. 如下 C++ 代码 (版本 2)</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#2838b0>template</span> <span style=color:#666>&lt;</span><span style=color:#2838b0>typename</span> Container<span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span>size_t binary_search_v2<span style=color:#888>(</span><span style=color:#2838b0>const</span> Container<span style=color:#666>&amp;</span> arr<span style=color:#888>,</span>
</span></span><span style=display:flex><span>                        <span style=color:#2838b0>const</span> <span style=color:#2838b0>typename</span> Container<span style=color:#666>::</span>value_type<span style=color:#666>&amp;</span> target<span style=color:#888>)</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>    size_t left <span style=color:#666>=</span> <span style=color:#444>0</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>    size_t right <span style=color:#666>=</span> arr<span style=color:#888>.</span>size<span style=color:#888>();</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>while</span> <span style=color:#888>(</span>left <span style=color:#666>&lt;</span> right<span style=color:#888>)</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>        size_t mid <span style=color:#666>=</span> left <span style=color:#666>+</span> <span style=color:#888>(</span>right <span style=color:#666>-</span> left<span style=color:#888>)</span> <span style=color:#666>/</span> <span style=color:#444>2</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>if</span> <span style=color:#888>(</span>arr<span style=color:#888>[</span>mid<span style=color:#888>]</span> <span style=color:#666>&lt;</span> target<span style=color:#888>)</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>            left <span style=color:#666>=</span> mid <span style=color:#666>+</span> <span style=color:#444>1</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#888>}</span> <span style=color:#2838b0>else</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>            right <span style=color:#666>=</span> mid<span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#888>}</span>
</span></span><span style=display:flex><span>    <span style=color:#888>}</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>return</span> left<span style=color:#888>;</span>
</span></span><span style=display:flex><span><span style=color:#888>}</span>
</span></span></code></pre></div><p>上面的代码可能不太好理解, 这就是二分搜索的难点所在, 只要修改一些细微之处, 就可以搜索满足各种条件的值.</p><p>为了证明该程序是正确的, 我们需要证明以下 4 个属性:</p><ol><li>程序的初始条件是正确的.</li><li>循环过程中, 始终维持某个不变式成立.</li><li>程序会终止.</li><li>程序终止时会产生正确的 (我们想要的) 结果.</li></ol><p>显然, 只要这些属性满足, 程序一定是正确的.</p><p>为了方便, 我们令 $a$ 表示我们需要搜索的有序数组, $x=\text{target}, L=0, R=\text{size}(a), m=\text{mid}$, 这样, 区间 $[L, R)$ 也可以表示我们需要搜索的有序数组. 在每次循环时, $\text{left, right}$ 的值分别保存给 $l, r$, 每轮循环结束时, $\text{left, right}$ 的值发生变化.</p><p>然后定义一个不变式 $P: (\text{right}-\text{left} &lt; r-l)\land ([L, \text{left}) &lt; x)\land (x \le[\text{right}, R))$. 注意 $\land$ 表示逻辑与, 不变式 $P$ 保证三个条件成立:</p><ol><li>$\text{right}-\text{left} &lt; r-l$ 表示每轮循环都会导致 $[\text{left, right})$ 缩小.</li><li>$[L, \text{left}) &lt; x$ 表示区间 $[L, \text{left})$ 的元素都比 $x$ 小</li><li>$x \le[\text{right}, R)$ 表示区间 $[\text{right}, R)$ 的元素都不比 $x$ 小.</li></ol><p>下面我们证明属性 1 即证明 $L, R$ 满足 $[L, L) &lt; x\land [R, R)$. 显然 $[L, L)$ 和 $[R, R)$ 为空, 因此属性 1 成立.</p><p>然后是属性 2. 令 $m=l+\lfloor (r-l)/2 \rfloor$, 并且对于前面的循环, 始终有 $P$ 成立.</p><p>如果 $\text{arr[mid] &lt; target}$, 那么 $\text{left}=m+1, \text{right}=r$, 我们需要证明</p><p>$$
\begin{aligned}
& \text{right - left} &lt; r - l\cr
& = r - (m + 1) &lt; r - l\cr
& = m + 1 > l\cr
& = l + \lfloor (r-l)/2 \rfloor + 1 > l\cr
& = \lfloor (r-l)/2 \rfloor > -1\cr
\end{aligned}
$$</p><p>因为循环条件保证了 $r > l$, 因此, $\lfloor (r-l)/2\rfloor \ge 0 > -1$. 此外, 显然 $[L, m+1) &lt; x$ 成立, $[r, R)$ 也成立 (前面的循环保证了它成立). 因此, $P$ 成立.</p><p>如果 $\text{arr[mid]} \ge \text{target}$, 那么 $\text{left}=l, \text{right}=m$, 我们需要证明</p><p>$$
\begin{aligned}
& \text{right - left} &lt; r - l\cr
& = m - l &lt; r - l\cr
& = m &lt; r\cr
& = l+\lfloor (r-l)/2\rfloor &lt; r\cr
& = \lfloor (r-l)/2\rfloor &lt; r - l
\end{aligned}
$$</p><p>我们可以轻松证明最后一行成立. 另外, $[L, l)&lt;x$ 成立, $x\le [m, R)$ 也成立. 因此 $P$ 成立. 属性 2 得证.</p><p>下面我们证明属性 3. 令整数函数(值为整数) $t=\text{right - left}$, 显然, 每次循环都会导致 $t$ 减小, 且直到循环终止前, $t$ 都大于 0. 因此, 程序一定会终止.</p><p>最后证明属性 4. 我们现在知道最后一次循环结束时 $P$ 成立, 在最后一次循环后 $\text{left}\ge \text{right}$ 然后退出循环. 由于 $P$ 成立, 所以 $[L, \text{left})&lt;x\le [\text{right}, R)$ 成立. 如果 $\text{left>right}$, 那么 $P$ 就不会成立了, 所以 $\text{left}$ 一定和 $\text{right}$ 相等, 因此 $[L, \text{left})&lt;x\le a[\text{left}]=a[\text{right}]$. 另外, $[\text{right}, R)$ 可能为空, 这意味着 $\text{right}$ 和 $R$ 相等. 此时数组中的所有元素都小于 x, 简单的返回 $\text{left}$ 即可.</p><p>综上, 我们知道最后 $\text{left}$ 指向的元素一定是第一个大于等于目标值的元素, 这个元素可能不存在, 那么 $\text{left}$ 指向数组的尾后元素.</p><h2 id=查找最右边的元素>查找最右边的元素</h2><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#2838b0>template</span> <span style=color:#666>&lt;</span><span style=color:#2838b0>typename</span> Container<span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span>size_t binary_search_v3<span style=color:#888>(</span><span style=color:#2838b0>const</span> Container<span style=color:#666>&amp;</span> arr<span style=color:#888>,</span>
</span></span><span style=display:flex><span>                        <span style=color:#2838b0>const</span> <span style=color:#2838b0>typename</span> Container<span style=color:#666>::</span>value_type<span style=color:#666>&amp;</span> target<span style=color:#888>)</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>    size_t left <span style=color:#666>=</span> <span style=color:#444>0</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>    size_t right <span style=color:#666>=</span> arr<span style=color:#888>.</span>size<span style=color:#888>();</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>while</span> <span style=color:#888>(</span>left <span style=color:#666>&lt;</span> right<span style=color:#888>)</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>        size_t mid <span style=color:#666>=</span> left <span style=color:#666>+</span> <span style=color:#888>(</span>right <span style=color:#666>-</span> left<span style=color:#888>)</span> <span style=color:#666>/</span> <span style=color:#444>2</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>if</span> <span style=color:#888>(</span>arr<span style=color:#888>[</span>mid<span style=color:#888>]</span> <span style=color:#666>&gt;</span> target<span style=color:#888>)</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>            right <span style=color:#666>=</span> mid<span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#888>}</span> <span style=color:#2838b0>else</span> <span style=color:#888>{</span>
</span></span><span style=display:flex><span>            left <span style=color:#666>=</span> mid <span style=color:#666>+</span> <span style=color:#444>1</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#888>}</span>
</span></span><span style=display:flex><span>    <span style=color:#888>}</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>return</span> left <span style=color:#666>==</span> <span style=color:#444>0</span> <span style=color:#666>?</span> arr<span style=color:#888>.</span>size<span style=color:#888>()</span> <span style=color:#666>:</span> left <span style=color:#666>-</span> <span style=color:#444>1</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span><span style=color:#888>}</span>
</span></span></code></pre></div><p>我们创建版本 3 的代码的不变式 $P:(\text{right}-\text{left} &lt; r-l)\land ([L, \text{left}) \le x)\land (x &lt;[\text{right}, R))$.</p><p>我们可以轻松的证明属性 1, 2, 3. 需要注意的是属性 4:</p><p>$$
\begin{aligned}
& P \land \text{left}\ge \text{right}\cr
& = [L, \text{left})\le x &lt; a[\text{left}]=a[\text{right}]
\end{aligned}
$$</p><p>因此, $\text{left}$ 最后指向的元素是第一个大于目标值的元素, 为了获得最后一个等于目标值的元素, 我们将 $\text{left}$ 减 1. 这个元素可能不存在, 此时仍然返回尾后元素.</p><p>注意到在每次迭代中, 版本 2 和版本 3 都比版本 1 少一次 if 判断. 这使得每一次的循环更快. 相对地, 总循环数更多了.</p><p>另外还有两种变种:</p><ul><li>总是查找大于目标值的最小元素. 这使用版本 3 的返回值再加 1 即可找到.</li><li>总是查找小于目标值的最大元素. 这使用版本 2 的返回值再减 1 即可找到.</li></ul><h2 id=搜索满足任意条件的元素>搜索满足任意条件的元素</h2><p>我们知道, 版本 2 的代码总能找到大于等于目标值的第一个元素, 版本 3 的代码总能找到大于目标值的第一个元素, 现在我们可以搜索满足 >= 和 > 谓词的元素, 也就可以搜索满足 &lt;= 和 &lt; 谓词的元素, 通过自定义谓词, 我们可以搜索满足任意条件的元素. 许多编程语言的标准库都支持搜索自定义条件的元素的二分搜索.</p><h2 id=libcxx-的实现>Libcxx 的实现</h2><p>C++ 标准库中实现的 <code>binary_search</code> 原型如下:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#2838b0>template</span><span style=color:#666>&lt;</span><span style=color:#2838b0>class</span> <span style=color:#287088>ForwardIt</span><span style=color:#888>,</span> <span style=color:#2838b0>class</span> <span style=color:#287088>T</span><span style=color:#888>,</span> <span style=color:#2838b0>class</span> <span style=color:#287088>Compare</span><span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#2838b0;font-style:italic>bool</span> binary_search<span style=color:#888>(</span>ForwardIt first<span style=color:#888>,</span> ForwardIt last<span style=color:#888>,</span> <span style=color:#2838b0>const</span> T<span style=color:#666>&amp;</span> value<span style=color:#888>,</span> Compare comp<span style=color:#888>);</span>
</span></span></code></pre></div><p>libcxx 中的实现如下:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#2838b0>template</span> <span style=color:#666>&lt;</span><span style=color:#2838b0>class</span> <span style=color:#287088>_Compare</span><span style=color:#888>,</span> <span style=color:#2838b0>class</span> <span style=color:#287088>_ForwardIterator</span><span style=color:#888>,</span> <span style=color:#2838b0>class</span> <span style=color:#287088>_Tp</span><span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#2838b0>inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
</span></span><span style=display:flex><span><span style=color:#2838b0;font-style:italic>bool</span>
</span></span><span style=display:flex><span>__binary_search<span style=color:#888>(</span>_ForwardIterator __first<span style=color:#888>,</span> _ForwardIterator __last<span style=color:#888>,</span> <span style=color:#2838b0>const</span> _Tp<span style=color:#666>&amp;</span> __value_<span style=color:#888>,</span> _Compare __comp<span style=color:#888>)</span>
</span></span><span style=display:flex><span><span style=color:#888>{</span>
</span></span><span style=display:flex><span>    __first <span style=color:#666>=</span> __lower_bound<span style=color:#666>&lt;</span>_Compare<span style=color:#666>&gt;</span><span style=color:#888>(</span>__first<span style=color:#888>,</span> __last<span style=color:#888>,</span> __value_<span style=color:#888>,</span> __comp<span style=color:#888>);</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>return</span> __first <span style=color:#666>!=</span> __last <span style=color:#666>&amp;&amp;</span> <span style=color:#666>!</span>__comp<span style=color:#888>(</span>__value_<span style=color:#888>,</span> <span style=color:#666>*</span>__first<span style=color:#888>);</span>
</span></span><span style=display:flex><span><span style=color:#888>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#2838b0>template</span> <span style=color:#666>&lt;</span><span style=color:#2838b0>class</span> <span style=color:#287088>_ForwardIterator</span><span style=color:#888>,</span> <span style=color:#2838b0>class</span> <span style=color:#287088>_Tp</span><span style=color:#888>,</span> <span style=color:#2838b0>class</span> <span style=color:#287088>_Compare</span><span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span>_LIBCPP_NODISCARD_EXT <span style=color:#2838b0>inline</span>
</span></span><span style=display:flex><span>_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
</span></span><span style=display:flex><span><span style=color:#2838b0;font-style:italic>bool</span>
</span></span><span style=display:flex><span>binary_search<span style=color:#888>(</span>_ForwardIterator __first<span style=color:#888>,</span> _ForwardIterator __last<span style=color:#888>,</span> <span style=color:#2838b0>const</span> _Tp<span style=color:#666>&amp;</span> __value_<span style=color:#888>,</span> _Compare __comp<span style=color:#888>)</span>
</span></span><span style=display:flex><span><span style=color:#888>{</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>typedef</span> <span style=color:#2838b0>typename</span> __comp_ref_type<span style=color:#666>&lt;</span>_Compare<span style=color:#666>&gt;::</span>type _Comp_ref<span style=color:#888>;</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>return</span> __binary_search<span style=color:#666>&lt;</span>_Comp_ref<span style=color:#666>&gt;</span><span style=color:#888>(</span>__first<span style=color:#888>,</span> __last<span style=color:#888>,</span> __value_<span style=color:#888>,</span> __comp<span style=color:#888>);</span>
</span></span><span style=display:flex><span><span style=color:#888>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#2838b0>template</span> <span style=color:#666>&lt;</span><span style=color:#2838b0>class</span> <span style=color:#287088>_Compare</span><span style=color:#888>,</span> <span style=color:#2838b0>class</span> <span style=color:#287088>_ForwardIterator</span><span style=color:#888>,</span> <span style=color:#2838b0>class</span> <span style=color:#287088>_Tp</span><span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span>_LIBCPP_CONSTEXPR_AFTER_CXX17 _ForwardIterator
</span></span><span style=display:flex><span>__lower_bound<span style=color:#888>(</span>_ForwardIterator __first<span style=color:#888>,</span> _ForwardIterator __last<span style=color:#888>,</span> <span style=color:#2838b0>const</span> _Tp<span style=color:#666>&amp;</span> __value_<span style=color:#888>,</span> _Compare __comp<span style=color:#888>)</span>
</span></span><span style=display:flex><span><span style=color:#888>{</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>typedef</span> <span style=color:#2838b0>typename</span> iterator_traits<span style=color:#666>&lt;</span>_ForwardIterator<span style=color:#666>&gt;::</span>difference_type difference_type<span style=color:#888>;</span>
</span></span><span style=display:flex><span>    difference_type __len <span style=color:#666>=</span> _VSTD<span style=color:#666>::</span>distance<span style=color:#888>(</span>__first<span style=color:#888>,</span> __last<span style=color:#888>);</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>while</span> <span style=color:#888>(</span>__len <span style=color:#666>!=</span> <span style=color:#444>0</span><span style=color:#888>)</span>
</span></span><span style=display:flex><span>    <span style=color:#888>{</span>
</span></span><span style=display:flex><span>        difference_type __l2 <span style=color:#666>=</span> _VSTD<span style=color:#666>::</span>__half_positive<span style=color:#888>(</span>__len<span style=color:#888>);</span>
</span></span><span style=display:flex><span>        _ForwardIterator __m <span style=color:#666>=</span> __first<span style=color:#888>;</span>
</span></span><span style=display:flex><span>        _VSTD<span style=color:#666>::</span>advance<span style=color:#888>(</span>__m<span style=color:#888>,</span> __l2<span style=color:#888>);</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>if</span> <span style=color:#888>(</span>__comp<span style=color:#888>(</span><span style=color:#666>*</span>__m<span style=color:#888>,</span> __value_<span style=color:#888>))</span>
</span></span><span style=display:flex><span>        <span style=color:#888>{</span>
</span></span><span style=display:flex><span>            __first <span style=color:#666>=</span> <span style=color:#666>++</span>__m<span style=color:#888>;</span>
</span></span><span style=display:flex><span>            __len <span style=color:#666>-=</span> __l2 <span style=color:#666>+</span> <span style=color:#444>1</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#888>}</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>else</span>
</span></span><span style=display:flex><span>            __len <span style=color:#666>=</span> __l2<span style=color:#888>;</span>
</span></span><span style=display:flex><span>    <span style=color:#888>}</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>return</span> __first<span style=color:#888>;</span>
</span></span><span style=display:flex><span><span style=color:#888>}</span>
</span></span></code></pre></div><p>可以看到 <code>binary_search</code> 实际上调用了 <code>lower_bound</code>, 这个函数返回范围 <code>[first, last)</code> 中不小于目标值 <code>value</code> 的第一个元素. 基本思想与版本 2 相同.</p><p><code>upper_bound</code> 返回 <code>[first, last)</code> 中大于目标值的 <code>value</code> 的第一个元素:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#2838b0>template</span> <span style=color:#666>&lt;</span><span style=color:#2838b0>class</span> <span style=color:#287088>_Compare</span><span style=color:#888>,</span> <span style=color:#2838b0>class</span> <span style=color:#287088>_ForwardIterator</span><span style=color:#888>,</span> <span style=color:#2838b0>class</span> <span style=color:#287088>_Tp</span><span style=color:#666>&gt;</span>
</span></span><span style=display:flex><span>_LIBCPP_CONSTEXPR_AFTER_CXX17 _ForwardIterator
</span></span><span style=display:flex><span>__upper_bound<span style=color:#888>(</span>_ForwardIterator __first<span style=color:#888>,</span> _ForwardIterator __last<span style=color:#888>,</span> <span style=color:#2838b0>const</span> _Tp<span style=color:#666>&amp;</span> __value_<span style=color:#888>,</span> _Compare __comp<span style=color:#888>)</span>
</span></span><span style=display:flex><span><span style=color:#888>{</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>typedef</span> <span style=color:#2838b0>typename</span> iterator_traits<span style=color:#666>&lt;</span>_ForwardIterator<span style=color:#666>&gt;::</span>difference_type difference_type<span style=color:#888>;</span>
</span></span><span style=display:flex><span>    difference_type __len <span style=color:#666>=</span> _VSTD<span style=color:#666>::</span>distance<span style=color:#888>(</span>__first<span style=color:#888>,</span> __last<span style=color:#888>);</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>while</span> <span style=color:#888>(</span>__len <span style=color:#666>!=</span> <span style=color:#444>0</span><span style=color:#888>)</span>
</span></span><span style=display:flex><span>    <span style=color:#888>{</span>
</span></span><span style=display:flex><span>        difference_type __l2 <span style=color:#666>=</span> _VSTD<span style=color:#666>::</span>__half_positive<span style=color:#888>(</span>__len<span style=color:#888>);</span>
</span></span><span style=display:flex><span>        _ForwardIterator __m <span style=color:#666>=</span> __first<span style=color:#888>;</span>
</span></span><span style=display:flex><span>        _VSTD<span style=color:#666>::</span>advance<span style=color:#888>(</span>__m<span style=color:#888>,</span> __l2<span style=color:#888>);</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>if</span> <span style=color:#888>(</span>__comp<span style=color:#888>(</span>__value_<span style=color:#888>,</span> <span style=color:#666>*</span>__m<span style=color:#888>))</span>
</span></span><span style=display:flex><span>            __len <span style=color:#666>=</span> __l2<span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#2838b0>else</span>
</span></span><span style=display:flex><span>        <span style=color:#888>{</span>
</span></span><span style=display:flex><span>            __first <span style=color:#666>=</span> <span style=color:#666>++</span>__m<span style=color:#888>;</span>
</span></span><span style=display:flex><span>            __len <span style=color:#666>-=</span> __l2 <span style=color:#666>+</span> <span style=color:#444>1</span><span style=color:#888>;</span>
</span></span><span style=display:flex><span>        <span style=color:#888>}</span>
</span></span><span style=display:flex><span>    <span style=color:#888>}</span>
</span></span><span style=display:flex><span>    <span style=color:#2838b0>return</span> __first<span style=color:#888>;</span>
</span></span><span style=display:flex><span><span style=color:#888>}</span>
</span></span></code></pre></div><p>基本思想与版本 3 相同.</p><h2 id=references>References</h2><ul><li><a href=https://en.wikipedia.org/wiki/Binary_search_algorithm>Binary search algorithm - Wikipedia</a></li><li><a href=https://stackoverflow.com/questions/7728478/c-template-class-function-with-arbitrary-container-type-how-to-define-it>c++ template class; function with arbitrary container type, how to define it? - Stack Overflow</a></li></ul></div></div></section><section class=section><div class=container><aside><div id=disqus_thread></div></aside><div id=show_comments><a id=load_comments class="button is-link">Load comments</a></div><script type=text/javascript>var hash,disqus_shortname="6cdh-github-io";function disqus(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}hash=window.location.hash.substr(1),hash.length>8&&hash.substring(0,8)==="comment-"?(disqus(),document.getElementById("show_comments").style.display="none"):document.getElementById("load_comments").onclick=function(){disqus(),document.getElementById("show_comments").style.display="none"}</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript rel=nofollow>comments powered by Disqus.</a></noscript></div></section><section class=section><div class="container has-text-centered"><p></p><p>Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/ribice/kiss>Kiss</a>.</p></div></section></body></html>